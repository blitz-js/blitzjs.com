---
title: Why use Blitz?
sidebar_label: Why Blitz?
---

### 1. Blitz Picks up Where Next.js Leaves Off {#1-where-nextjs-ends}

Next.js does amazing at handling all the React and build stuff. But beyond
that, you are left to your own devices.

Blitz adds all the missing features and functionality that let's you build
a fullstack Next.js app, like a typesafe API layer, middleware, and
authentication.

### 2. Typesafe Data Layer {#2-data-layer}

Blitz popularized RPC as an alterative to REST or GraphQL APIs. With
Blitz, you can import your server code directly into the frontend so you
don't need to build an API and do data fetching from the frontend. At
build time, Blitz automatically inserts an RPC API call that runs the
server code on the server. Essentially, Blitz abstracts your API into a
compile step.

This is a game changer for React app development because it eliminates an
entire portion of traditional React app architecture. This means it's
easier to learn, faster to develop, and more fun to build things!

That said, you can continue doing data fetching via REST or GraphQL like
you've always done. Blitz doesn't restrict this in any way.

### 3. Authentication {#3-authentication}

Blitz offers session management that works with any identity provider,
including self-hosted email/password and third party services.
Authentication is something that's complicated and difficult to implement
correctly. Having it built into Blitz saves you a ton of time and
potential security vulnerabilities.

Building an awesome UX with auth in Next.js is very tricky and tedious,
but Blitz gives you best-in-class DX for free.

### 4. Code Scaffolding {#4-code-scaffolding}

There are two main ways to reduce the amount of code you have to write by
hand:

1. Code generation
2. Code scaffolding

**Code generation** means a library generates code for you. Examples are
graphql-code-generator which generates code from GraphQL queries and
Hasura which generates an entire GraphQL API from your database schema.
Usually codegen has no way to fully customize the generated code. You're
at the mercy of the library for what it supports. Often you will run into
edge cases that codegen has no solution for. And you can't fix it because
you don't own the code.

**Code scaffolding** means initial code is scaffolded into your project
for you. From then on, you have full ownership over all the code and can
customize it as much you need. A downside of code scaffolding is that you
don't get automatic updates like you do with code generation from a
third-party library. But the huge upside is that you are guaranteed to
never be limited by someone else's design choices which you have no way to
change.

Blitz is a huge fan of code scaffolding. We have a whole slew of
[`blitz generate`](./cli-generate) commands for scaffolding code into your
project. It's still early days for our code scaffolding â€” we have a lot of
powerful features that still need to be added, including the ability to
add your own custom scaffold templates.

### 5. Recipes {#5-recipes}

Recipes are one-line commands for scaffolding code into your project from
an MDX recipe on npm or a git repository.

Examples:

- `blitz install tailwind` - one command to install and configure tailwind
- `blitz install chakra-ui` - one command to install and configure chakra
- `blitz install material-ui` - one command to install and configure
  material-ui

Recipes are super powerful. They can change almost anything in your
project, including adding dependencies, changing code, adding code, etc.
They are written via MDX and can be composed like React components.

### 6. New App Development {#6-new-app-development}

A new Next.js app is totally bare-bones. So every time you start a Next.js
project, you have to spend hours setting up all the basics like eslint,
prettier, husky git hooks, etc.

A new Blitz app saves you a ton of time because all that is pre-configured
for you! For sure you can always customize it later, but having a working
starting point is awesome.

### 7. Route Manifest {#7-route-manifest}

Next.js requires you to manually type out page locations. Blitz comes with
a [Route Manifest](./route-manifest), so you can do:

```tsx
<Link href={Routes.ProductsPage({ productId: 123 })} />
// instead of
<Link href={`/products/${123}`} />
```

This improves expressiveness and simplifies moving pages to other
location.
