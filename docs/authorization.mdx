---
title: Authorization & Security
sidebar_label: Authorization & Security
---

Authorization is the act of allowing or disallowing access to data and pages in your application.

## Secure Data, Not Pages

If you have built React apps before, probably you enforced authorization on pages by checking if the session exists and rendering different things based on that, like `AuthorizedLayout` vs `UnauthorizedLayout`. Or checking for a session and redirecting somewhere if it doesn't exist.

But because of the nature of static pre-rendering, this method results in a very poor user experience in Blitz apps.

**In Blitz apps, you want to secure data, not pages.** And then by extension, your pages will be secured too.

You secure data by calling [`ctx.session.$authorize()`](#ctxsessionauthorize) inside all the queries and mutations that you want secured. You can also secure [API routes](./api-routes) the same way. This call will throw `AuthenticationError` if the user is not logged in, and it will throw `AuthorizationError` if the user is logged in but doesn't have the required permissions.

### Optimistic Authorization

Because all your data is secured, you can build your entire UI in an optimistic fashion. You can assume that the user is logged in and has the required permissions. By doing this, you always render the content an authenticated user will see and rely on the thrown Errors to handle unauthorized users.

### Handle Unauthorized Users

Because you are calling `ctx.session.$authorize()` in queries and mutations, the way to detect unauthorized users is to watch for `AuthenticationError` and `AuthorizationError` in your UI.

In React, the way you catch errors in your UI is to use an [error boundary](https://reactjs.org/docs/error-boundaries.html).

In Blitz, the recommended approach is to have a top level error boundary inside `_app.tsx` so that these errors are handled from everywhere in our app. And then if you need, you can also place more error boundaries at other places in your app.

Here's how these errors are handled by default in new Blitz apps:

- If `AuthenticationError` is thrown, directly show the user a login form instead of redirecting to a separate route. This prevents the need to manage redirect URLs. Once the user logs in, the error boundary will reset and the user can access the original page they wanted to access.
- If `AuthorizationError` is thrown, display an error stating such.

And here's the default `RootErrorFallback` that's in `app/pages/_app.tsx`. You can customize it as required for your needs.

```tsx
function RootErrorFallback({error, resetErrorBoundary}) {
  if (error.name === "AuthenticationError") {
    return <LoginForm onSuccess={resetErrorBoundary} />
  } else if (error.name === "AuthorizationError") {
    return (
      <ErrorComponent
        statusCode={error.statusCode}
        title="Sorry, you are not authorized to access this"
      />
    )
  } else {
    return (
      <ErrorComponent statusCode={error.statusCode || 400} title={error.message || error.name} />
    )
  }
}
```

For more information on error handling in Blitz, see the [Error Handling documentation](./error-handling).

## Displaying Different Content Based on User Role

There's two approaches you can use to check the user role in your UI.

#### `useCurrentUser()`

New Blitz apps by default have a `useCurrentUser()` hook and a corresponding `getCurrentUser` query.

This makes a network call to the backend, so you'll need to handle the loading state.

```tsx
import {useCurrentUser} from "app/hooks/useCurrentUser"

const user = useCurrentUser()

if (user?.role === "admin") {
  return /* admin stuff */
} else {
  return /* normal stuff */
}
```

#### `useSession()`

Another way is to use the [`useSession()`](./session-management#session-on-the-client) hook to read the user role from the session's `publicData`.

This is available on the client without making a network call to the backend, so it's available faster than the `useCurrentUser()` approach.

However, due to the nature of static pre-rendering, the `session` will not exist on the very first render on the client. This causes a quick "flash" on first load. Unfortunately there's no way to get around this because React requires the first render on the client to always match the render on the server (which in this case is because of static pre-rendering and the session doesn't exist during that).

If this "flash" of unauthentication is unacceptable for your use case, the alternative approach is to use [`getServerSideProps`](./get-server-side-props) which opts you into SSR. And with SSR, the entire page is rendered on the server for each page load. This allows the very first page render to correctly match the user's role.

```tsx
import {useSession} from "blitz"

const session = useSession()

if (!session.isLoading && session.roles.includes("admin")) {
  return /* admin stuff */
} else {
  return /* normal stuff */
}
```

## `isAuthorized` Adapters

The implementation of `ctx.session.$isAuthorized()` and `ctx.session.$authorize()` are defined by an adapter which you set in the `sessionMiddleware()` config.

##### `ctx.session.$isAuthorized()`

Always returns a boolean indicating if user is authorized

##### `ctx.session.$authorize()`

**Throws an error** if the user is not authorized. This is what you most commonly use to secure your queries and mutations.

```ts
import {Ctx} from "blitz"
import {GetUserInput} from "./somewhere"

export default async function getUser({where}: GetUserInput, ctx: Ctx) {
  // highlight-start
  ctx.session.$authorize("admin")
  // highlight-end

  return await db.user.findOne({where})
}
```

#### `simpleRolesIsAuthorized` (default in new apps)

##### Setup

To use, add it to your `sessionMiddleware` configuration (this is already set up by default in new apps).

```js
// blitz.config.js
const {sessionMiddleware, simpleRolesIsAuthorized} = require("@blitzjs/server")

module.exports = {
  middleware: [
    sessionMiddleware({
      // highlight-start
      isAuthorized: simpleRolesIsAuthorized,
      // highlight-end
    }),
  ],
}
```

And if using Typescript, set the type in `types.ts` like this:

```ts
import {SimpleRolesIsAuthorized} from "@blitzjs/server"

type Role = "ADMIN" | "USER"

declare module "blitz" {
  // highlight-start
  export interface Session {
    isAuthorized: SimpleRolesIsAuthorized<Role>
  }
  // highlight-end
}
```

##### `ctx.session.$isAuthorized(roleOrRoles?: string | string[])`

Example usage:

```ts
// User not logged in
ctx.session.$isAuthorized() // false

// User logged in with 'customer' role
ctx.session.$isAuthorized() // true
ctx.session.$isAuthorized("customer") // false
ctx.session.$isAuthorized("admin") // false
```

##### `ctx.session.$authorize(roleOrRoles?: string | string[])`

Example usage:

```ts
// User not logged in
ctx.session.$authorize() // throws AuthenticationError

// User logged in with 'customer' role
ctx.session.$authorize() // success - no error
ctx.session.$authorize("customer") // success - no error
ctx.session.$authorize("admin") // throws AuthorizationError
ctx.session.$authorize(["admin", "customer") // success - no error
```

### Making a Custom Adapter

An `isAuthorized` adapter must conform to the following function signature.

```ts
type CustomIsAuthorizedArgs = {
  ctx: any
  args: [/* args that you want for session.$authorize(...args) */]
}
export function customIsAuthorized({ctx, args}: CustomIsAuthorizedArgs) {
  // can access ctx.session, ctx.session.userId, etc
}
```

##### Example

Here's the source code for the `simpleRolesIsAuthorized` adapter include in Blitz core as of Jan 26, 2021.

```ts
type SimpleRolesIsAuthorizedArgs = {
  ctx: any
  args: [roleOrRoles?: string | string[], options?: {if?: boolean}]
}

export function simpleRolesIsAuthorized({ctx, args}: SimpleRolesIsAuthorizedArgs) {
  const [roleOrRoles, options = {}] = args
  const condition = options.if ?? true

  // No roles required, so all roles allowed
  if (!roleOrRoles) return true
  // Don't enforce the roles if condition is false
  if (!condition) return true

  const rolesToAuthorize = []
  if (Array.isArray(roleOrRoles)) {
    rolesToAuthorize.push(...roleOrRoles)
  } else if (roleOrRoles) {
    rolesToAuthorize.push(roleOrRoles)
  }
  for (const role of rolesToAuthorize) {
    if ((ctx.session as SessionContext).$publicData.roles!.includes(role)) return true
  }
  return false
}
```
