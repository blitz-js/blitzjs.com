---
title: Server Utilities
sidebar_label: Server Utilities
---

## `resolver.pipe`

This is a functional utility that makes it easier and cleaner to write complex resolvers.

- It reduces the need for explicit Typescript types
- Validate input data with a zod schema with `resolver.zod()`
- Authorize users with `resolver.authorize()`
- Enables functional composition

### Example

```ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

export const CreateProject = z.object({
  name: z.string(),
  dueDate: z.date().optional(),
  orgId: z.number().optional(),
})

export default resolver.pipe(
  resolver.zod(CreateProject),
  resolver.authorize(),
  // Set default orgId
  (input, {session}) => ({...input, orgId: input.orgId ?? session.orgId}),
  async (input, ctx) => {
    console.log("Creating project...", input.orgId)
    const project = await db.project.create({
      data: input,
    })
    console.log("Created project")
    return project
  },
)
```

:::info
The input type of the entire composed resolver function is determined by the input type of the **first** argument to pipe.

This means you will almost always want `resolver.zod()` to be the first in the pipe.
:::

### API

#### Arguments

It accepts from 1 to N functions which take input data as first argument and [middleware `ctx`](./middleware) as the second argument.

The output of the first function is the first input argument of the next function. The output of the last function is the final resolver result data that will be sent to the client.

The Typescript types are automatically inferred from one function to the next.

<!-- prettier-ignore -->
```js
// 1 function
const resolver = resolver.pipe((input: ResolverInput, ctx: Ctx) => ResolverOutput)
// 2 functions
const resolver = resolver.pipe(
  (input: ResolverInput, ctx: Ctx) => A),
  (input: A, ctx: Ctx) => ResolverOutput),
)
// 3 functions
const resolver = resolver.pipe(
  (input: ResolverInput, ctx: Ctx) => A),
  (input: A, ctx: Ctx) => B),
  (input: B, ctx: Ctx) => ResolverOutput),
)
// ... etc
```

#### Returns

This returns a composed function of type `(input, ctx) => Promise<result>` which is the standard resolver type.

## `resolver.zod`

This is a resolver adapter for [Zod](https://github.com/colinhacks/zod), an awesome input validation library. It takes a zod schema and runs `schema.parse` on the input data.

### Example

<!-- prettier-ignore -->
```ts
import {resolver} from 'blitz'
import * as z from "zod"

export const CreateProject = z.object({
  name: z.string(),
  dueDate: z.date().optional(),
  orgId: z.number().optional(),
})

export default resolver.pipe(
  resolver.zod(CreateProject), // highlight-line
  async (input, ctx) => {
    // stuff
  },
)
```

### API

<!-- prettier-ignore -->
```js
const pipeFn = resolver.zod(MyZodSchema)
```

#### Arguments

- `ZodSchema:` a [zod](https://github.com/colinhacks/zod) schema
  - **Required**

#### Returns

A function to give `resolver.pipe` of type `(rawInput, ctx: Ctx) => validInput`

## `resolver.authorize`

### Example

<!-- prettier-ignore -->
```ts
import {resolver} from 'blitz'

export default resolver.pipe(
// highlight-start
  resolver.authorize(),
  // resolver.authorize('admin'),
// highlight-end
  async (input, ctx) => {
    // stuff
  },
)
```

### API

<!-- prettier-ignore -->
```js
const pipeFn = resolver.authorize(...isAuthorizedArgs)
```

#### Arguments

- `...isAuthorizedArgs`: The same arguments as your [`isAuthorized` adapter](./authorization#isauthorized-adapters)

#### Returns

A function to give `resolver.pipe` of type `(input, ctx: Ctx) => input`

## `invokeWithMiddleware`

This is for imperatively invoking queries/mutations on the server. It ensures appropriate middleware is run before/after your resolver.

### Example

```tsx
import {invokeWithMiddleware, GetServerSideProps, Link, BlitzPage, PromiseReturnType} from "blitz"
import getProducts from "app/products/queries/getProducts"

type PageProps = {
  products: PromiseReturnType<typeof getProducts>
}

export const getServerSideProps: GetServerSideProps<PageProps> = async ({req, res}) => {
  const products = await invokeWithMiddleware(getProducts, {orderBy: {id: "desc"}}, {req, res})

  return {
    props: {products},
  }
}

const Page: BlitzPage<PageProps> = function ({products}) {
  return (
    <div>
      <h1>Products</h1>
      <div id="products">
        {products.map((product) => (
          <p key={product.id}>
            <Link href="/products/[handle]" as={`/products/${product.handle}`}>
              <a>{product.name}</a>
            </Link>
          </p>
        ))}
      </div>
    </div>
  )
}
export default Page
```

### API

<!-- prettier-ignore -->
```js
const results = await invokeWithMiddleware(resolver, resolverInputArguments, {req, res}))
```

#### Arguments

- `resolver:` A Blitz [query resolver](./query-resolvers) or [mutation resolver](./mutation-resolvers)
  - **Required**
- `resolverInputArguments`
  - **Required**
  - The arguments that will be passed to `resolver`
- Other
  - `req`
    - **Required**
    - The BlitzApiRequest object
  - `res`
    - **Required**
    - The BlitzApiResponse object
  - `middleware`
    - Optional
    - Array of middleware that will be ran in addition to global middleware and any local middleware defined on the query/mutation.

#### Returns

- `results`
  - The exact results returned from the resolver
